def dfs(s,t):
    if s == t:             #递归结束，输出一个全排列    
        print(b[0:n])           
    else: 
        for i in range(t):
            if vis[i] == False:
               vis[i] = True
               b[s] = a[i]     #存排列
               dfs(s+1,t)
               vis[i] = False           

a = [1,2,3,4,5,6,7,8,9]
b = [0]*10                #记录生成的一个全排列
vis = [False]*10          #记录第i个数是否用过
n = 3
dfs(0,n)                  #前n个数的全排列

# 执行您提供的代码过程如下：
# 程序开始时，我们先初始化了一个数组a为[1,2,3,4,5,6,7,8,9]，这是我们要进行排列的原始数组。
# 我们还初始化了一个长度为10的数组b，用来记录生成的全排列，初始值为0。
# 另外一个长度为10的布尔数组vis，用来标记数组a中的每个数字是否已经被用在排列中，初始值为False。
# 我们设定了一个变量n为3，表示我们要生成的全排列的长度。
# 调用dfs(0, n)函数开始递归搜索全排列。
# 在dfs函数中，如果s等于t（即递归深度等于排列长度），我们将当前的排列从b数组中取出前n个元素，添加到输出列表中。
# 如果s不等于t，我们遍历数组a，对于每个还没有被使用的数字（vis[i] == False），我们将它添加到当前排列的s位置，并将vis[i]设置为True，表示该数字已经被使用。
# 然后，我们递归调用dfs(s+1, t)，尝试下一个位置的数字。
# 在递归返回后，我们需要将vis[i]复位为False，以便该数字可以被后续的排列再次使用。
# 执行完毕后，我们得到以下全排列的输出结果：
# plaintext
# [1, 2, 3]
# [1, 3, 2]
# [2, 1, 3]
# [2, 3, 1]
# [3, 1, 2]
# [3, 2, 1]